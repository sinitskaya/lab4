# Реализация приоритетной очереди на основе d-кучи, упорядоченной таблицы и бинарного поискового дерева и её применение для построения остовного дерева с помощью алгоритма Краскала
## Содержание
* [Постановка задачи](#Постановка-задачи)
* [Руководство пользователя](#Руководство-пользователя)
  * [Использование реализации пирамидальной сортировки](#Использование-реализации-пирамидальной-сортировки)
  * [Использование реализации алгоритма Дейкстры](#Использование-реализации-алгоритма-Дейкстры)
  * [Использование реализации алгоритма Краскала](#Использование-реализации-алгоритма-Краскала)
* [Руководство программиста](#Руководство-программиста)
  * [Используемые технологии](#Используемые-технологии)
  * [Общая структура репозитория](#Общая структура-репозитория)
  * [Описание структуры решения](#Описание-структуры-решения)
  * [Описание структур данных](#Описание-структур-данных)
	  * [D-куча](#d-куча)
	  * [Бинарное поисковое дерево](#Бинарное-поисковое-дерево)
	  * [Таблицы](#Таблицы)
	    * [Просматриваемые таблицы](#Просматриваемые-таблицы)
	    * [Упорядоченные таблицы](#Упорядоченные-таблицы)
    * [Приоритетные очереди](#Приоритетные-очереди)
    * [Разделенные множества](#Разделенные-множества)
  * [Описание алгоритмов](#Описание-алгоритмов)
		* [Пирамидальная сортировка](#Пирамидальная-сортировка)
		* [Алгоритм Дейкстры](#Алгоритм-Дейкстры)
		* [Алгоритм Краскала](#Алгоритм-Краскала)
  * [Программная реализация структур данных](#Программная-реализация-структур-данных)
		* [Программная реализация d-кучи](#Программная-реализация-d-кучи)
		* [Программная реализация бинарного поискового дерева](#Программная-реализация-бинарного-поискового-дерева)
		* [Программная реализация просматриваемых таблиц](#Программная-реализация-просматриваемых-таблиц)
		* [Программная реализация упорядоченных таблиц](#Программная-реализация-упорядоченных-таблиц)
		* [Программная реализация приоритетной очереди на основе D-кучи](#Программная-реализация-приоритетной-очереди-на-основе-d-кучи)
		* [Программная реализация приоритетной очереди на основе бинарного поискового дерева](#Программная-реализация-приоритетной-очереди-на-основе-бинарного-поискового-дерева)
		* [Программная реализация приоритетной очереди на основе упорядоченной таблицы](#Программная-реализация-приоритетной-очереди-на-основе-упорядоченной-таблицы)
		* [Программная реализация разделенных множеств](#Программная-реализация-разделенных-множеств)
		* [Программная реализация графа](#Программная-реализация-графа)
* [Заключение](#Заключение)
* [Литература](#Литература)

## Постановка задачи

1. Разработать статические библиотеки, реализующие следующие структуры данных:
	- d-кучу;
	- бинарное поисковое дерево;
	- граф;
	- разделенные множества;
	- таблицу;
	- просматриваемую таблицу;
	- упорядоченную таблицу;
	- приоритетную очередь, основанную на d-куче;
	- приоритетную очередь, основанную на бинарном поисковом дереве;
	- приоритетную очередь, основанную на упорядоченной таблице.
2. Написать тестирующую программу для каждого метода каждой структуры данных с помощью Google C++ Testing Framework.
3. Написать приложение для демонстрации работы d-кучи (пирамидальная сортировка).
4. Написать приложение для демонстрации работы приоритетной очереди, основанной на d-куче (алгоритм Дейкстры):
	- входные данные - связный неориентированный взвешенный граф без петель;
	- выходные данные:
	    - список кратчайших путей до каждой вершины графа;
	    - список предшествующий вершин.
5. Написать приложение для демонстрации работы приоритетных очередей (на базе D-кучи, бинарного поискового дерева и упорядоченной таблицы) и разделенных множеств (алгоритм Краскала):
	- входные данные - связный неориентированный взвешенный граф без петель;
	- выходные данные - граф, представляющий минимальное остовное дерево для исходного графа.

## Руководство пользователя

###Использование реализации пирамидальной сортировки

####Запуск приложения и ввод данных

Программа предназначена для сортировки d-кучи.
Для запуска приложения нужно открыть исполняемый файл `sample_sort.exe`.
Программа запросит арность кучи и количество элементов. Программа сгенерирует кучу, с учетом ваших данных. На экран выведется сначала исходная куча, затем отсортированная.

####Пример:

1) После запуска программы необходимо ввести арность кучи:

![1](/img/sort1.png)

2) Затем необходимо ввести количество элементов в куче:

![2](/img/sort2.png)

3) После этого программа выведет исходную и отсортированную кучу:

![3](/img/sort3.png)

###Использование реализации алгоритма Дейкстры

####Запуск приложения и ввод данных

Программа предназначена для поиска кратчийших путей во взвешенном неориентированном графе от стартовой вершины до всех остальных вершин графа.
Для запуска приложения нужно открыть исполняемый файл `sample_Dijkstra.exe`.
Программа предлагает пользовательский ввод или пример, предлагаемый программой.
Программа попросит ввести количество вершин графа, значения весов ребер. Cтартовая вершина по умолчанию нулевая. Результатом будет вывод кратчайших путей от стартовой вершины и номеров предшествующих вершин.

####Пример:

1)Продемонстрируем пользовательский ввод:

![4](/img/d1.png)

2) Необходимо ввести количество вершин графа:

![5](/img/d2.png)

3) Введите значения весов рёбер графа, соединяющих вершины i и j:

![6](/img/d3.png)

4) Получим результат:

![7](/img/d4.png)

###Использование реализации алгоритма Краскала

####Запуск приложения и ввод данных

Программа предназначена для построения минимального остовного дерева для взвешенного неориентированного графа. 
Для запуска приложения нужно открыть исполняемый файл `sample_Kruskal.exe`.
Программа попросит выбрать структуру данных, на которой будет основоваться приоритетная очередь, и количество вершин графа.
Программа предлагает пользовательский ввод или пример, предлагаемый программой.
Результатом работы программы будет вывод списка ребер, составляющих минимальное остовное дерево, и их весов.

####Пример

1) Выбираем структуру данных для приоритетной очереди:

![8](/img/k1.png)

2) Продемонстрируем пользовательский ввод:

![9](/img/k2.png)

2) Вводим число вершин графа:

![10](/img/k3.png)

3) Вводим данные:

![11](/img/k4.png)

4) Программа завершила работу и вывела результат на экран:

![12](/img/k5.png)

##Руководство программиста

###Используемые технологии

В ходе выполнения работы использованы следующее ПО:
- Среда разработки Microsoft Visual Studio 2012.
- Фреймворк для написания автоматических тестов Google Test.
- Система контроля версий Git.

###Общая структура репозитория

Репозиторий содержит следующие директории и файлы:

* [`gtest`](https://github.com/sinitskaya/lab4/tree/master/gtest) - библиотека GoogleTest.
* [`include`](https://github.com/sinitskaya/lab4/tree/master/include) - директория для размещения заголовочных файлов и реализаций структур данных.
* [`sample_Dijkstra`](https://github.com/sinitskaya/lab4/tree/master/samples) - директория для размещения исходного кода приложения алгоритма Дейкстры, Краскала, пирамидальной сортировки.
* [`test`](https://github.com/sinitskaya/lab4/tree/master/test) - директория для размещения тестов.
* [`sln`](https://github.com/sinitskaya/lab4/tree/master/sln/vc12) - директория с файлими решений (на данный момент Visual Studio 2012).
* [`img`](https://github.com/sinitskaya/lab4/tree/master/img) - директория с изображениями для отчета;
* [`src`](https://github.com/sinitskaya/lab4/tree/master/src) - директория для размещения реализационных файлов

###Описание структуры решения

Решение состоит из 12 проектов:

* `bin_TREE_lib` - статическая библиотка, содержащая объявление и реализацию шаблонного класса `BSearchTree`.
* `d_heap_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного класса `D_heap`.
* `table` - статическая библиотека, содержащая объявление и реализацию шаблонных классов `TabRecord`, `Table`, `ScanTable`, `SortTable`.
* `graph_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного классов `Graph`.
* `disjoint_set_lib` - статическая библиотека, содержащая объявление и реализацию шаблонного класса разделенных множестве `Disjoint_set`.
* `queue_lib` - статическая библиотека, содержащая объявление и реализацию абстрактного шаблонного класса приоритетной очереди и шаблонных классов-наследников приоритетных очередей, основанных на d-куче, бинарном поисковом дереве и упорядоченной таблице `Queue`, `D_heap_Queue`, `BSearchTree_Queue`, `SortTable_Queue`.
* `algorithm` - статическая библиотека, содержащая объявление и реализацию шаблонного класса `Algorithm`, содержащего алгоритм Крускала и Дейкстры.
* `sample_Dijkstra` - консольное приложение для демонстрации работы алгоритма Дейкстры.
* `sample_Kruskal` - консольное приложение для демонстрации работы алгоритма Краскала.
* `sample_sort` - консольное приложение для демонстрации работы пирамидальной сортировки.
* `gtest` - фреймворк Google Test.
* `test` - консольное приложение для проверки правильности реализации классов `BSearchTree`, `D_heap`, `D_heap_Queue`, `BSearchTree_Queue`, `SortTable_Queue`, `Disjoint_set`, `Scan_table`, `Sort_table`.


###Описание структур данных

####D-куча

D-куча - завершенное d-арное дерево, содержащее набор однотипных элементов, со следующими свойствами:
- каждый узел, не являющийся листом, за исключением, быть может, одного имеет ровно d потомков. Один узел, являющийся исключением, может иметь от 1 до d-1 потомка;
- если h - глубина дерева, то для любого i = 1, ..., k-1 такое дерево имеет ровно d^i узлов глубины i;
- количество узлов глубины k в дереве глубины k может варьироваться от 1 до d^k;
- каждый узел имеет вес. Иначе говоря, каждому узлу дерева присвоен ключ такого типа данных, на котором определен порядок сравнения;
- ключ элемента, приписанного узлу i, не превосходит ключа любого из своих потомков.

######Основные операции
* Транспонирование `Swap` (трудоемкость = O(1))
```
ТРАНСПОНИРОВАНИЕ(i, j)
{
	tmp = key[i];
	key[i] = key[j];
	key[j] = tmp;
}
```
* Всплытие `SiftUp` (трудоемкость = log(n)):
```
ВСПЛЫТИЕ(i)
{
	p = (i - 1) / d;
	while (i != 0 && key[p] > key[i])
	{	
		ТРАНСПОНИРОВАНИЕ(i, p);
		i = p;
		p = (i - 1) / d;
	}
}
```
* Погружение `SiftDown` (трудоемкость = О(d*log(n)):
```
ПОГРУЖЕНИЕ(i)
{
	с = minchild(i); 
	while (i != 0 && key[c] < key[i])
	{
		ТРАНСПОНИРОВАНИЕ(i, c);
		i = c;
		c = minchild(i);
	}
}
```
* Вставка элемента `Push` (трудоемкость = О(log(n)):
```
ВСТАВКА(x)
{
	key[size] = x;
	ВСПЛЫТИЕ(size);
	size++;
}
```
* Удаление элемента c минимальным ключом `RemoveMin` (трудоемкость = О(log(n)):
```
УДАЛЕНИЕ_С_МИНИМАЛЬНЫМ_КЛЮЧОМ()
{
	key[0] = key[size - 1];
	size--;
	ПОГРУЖЕНИЕ(0);
}
```
* Удаление элемента с заданным ключом `Remove` (трудоемкость = О(log(n)):
```
УДАЛЕНИЕ(i)
{
	key[i] = key[size - 1];
	size--;
	ПОГРУЖЕНИЕ(i);
}
```
* Окучивание `Heapify` (трудоемкость = О(log(n)):
```
ОКУЧИВАНИЕ()
{
	for(int i = size - 1; i >= 0; i--)
	ПОГРУЖЕНИЕ(i);
}
```
* Индекс минимального ребенка `MinChild` (трудоемкость = O(1)):
```
MINCHILD(i)
{
	minc = i*d+1;
	if( minc < n-1 )
		t = i*d + 1;
	else
		t = n-1;
	for (int k=minc; k<=t; k++)
		if(keys[k] < keys[minc])
			minc = k;
}
```

####Бинарное дерево

#####Бинарное поисковое дерево
Бинарное поисковое дерево - это двоичное дерево, обладающее следующими свойствами:
* каждый узел имеет не больше двух потомков;
* любое поддерево является бинарным поисковым деревом;
* значение ключа любого узла левого поддерева меньше значения ключа корневого узла;
* значение ключа любого узла правого поддерева больше значения ключа корневого узла.

######Основные операции
* Вставка элемента `Insert` (трудоемкость = log(n)):
```
ВСТАВКА(Node)
{
	x = root;
	while(x != 0)
	{
		y = x;
		if (node->key >= x->key) 
			x = x->right;
		else 
			x = x->left;
	}
	if (node->key >= y->key) 
		y->right = node;
	else 
		y->left = node;
	node->parent = y;
}
```
* Удаление элемента `Delete` (трудоемкость = log(n)):
```
УДАЛЕНИЕ(key)
{
	x = FindKey(root_, key);
	
	//list
	if((x->left == 0) && (x->right == 0))
	{
		if(x->parent!=0)
		{
			if(x->parent->right == x)
				x->parent->right = 0;
			else
				x->parent->left = 0;
			delete x;
			return;
		}
	}

	//1 потомок
	if((x->left==0) && (x->right!=0))
	{
		if(x->parent!=0) 
		{
			y = x->right;
			y->parent = x->parent;

			if(x->parent->right==x)
				x->parent->right = y;
			else
				x->parent->left = y;
			delete x;
			return;
		}
	}
	if((x->left!=0) && (x->right==0))
	{
		if(x->parent!=0)
		{
			y = x->left;
			y->parent = x->parent;
			if(x->parent->left==x)
				x->parent->left = y;
			else
				x->parent->right = y;
			delete x;
			return;
		}
	}

	//2 потомка
	y = FindMin(x->right);
	x->e.key = y->e.key;
	y->parent->left = y->right;
	
	if(y->right!=0)
		y->right->parent = y->parent;
	delete y;
}
```
* Поиск элемента `FindKey` (трудоемкость = n):
```
ПОИСК(key)
{
	while ((root_) && (root_->e.key != key1))
		if (key1 < root_->e.key)
			root_ = root_->left;
		else
			root_ = root_->right;
	return root_;
}
```
* Обход в прямом порядке `WorkAroundForward`:
```
ОБХОД_В_ПРЯМОМ_ПОРЯДКЕ(Node *tree)
{
	cout << key;
	ОБХОД_В_ПРЯМОМ_ПОРЯДКЕ(tree->left);
	ОБХОД_В_ПРЯМОМ_ПОРЯДКЕ(tree->right);
}
```
* Обход в обратном порядке `WorkAroundReverse`:
```
ОБХОД_В_ОБРАТНОМ_ПОРЯДКЕ(Node *tree)
{
	ОБХОД_В_ОБРАТНОМ_ПОРЯДКЕ(tree->left);
	ОБХОД_В_ОБРАТНОМ_ПОРЯДКЕ(tree->right);
	cout << key;
}
```
* Симметричный обход `WorkAroundSymmetric`:
```
СИММЕТРИЧНЫЙ_ОБХОД(Node *tree)
{
    	СИММЕТРИЧНЫЙ_ОБХОД(tree->left);
	cout << key;
	СИММЕТРИЧНЫЙ_ОБХОД(tree->right);
}
```
* Обход в ширину `WorkAroundWidth`:
```
ОБХОД_В_ШИРИНУ()
{
	queue <Node*> q;
	q.ВСТАВКА(tree);	
	while (!q.empty())
	{
		Node *tmp = q.top();
		cout << key;
		q.pop();		
		if (tmp->left != 0)
			q.ВСТАВКА (tmp->left);
		if (tmp->right != 0)
			q.ВСТАВКА (tmp->right);		
	}
}
```
* Обход в глубину `WorkAroundDepth`:
```
ОБХОД_В_ГЛУБИНУ
{
	stack<Node*> s;
	s.push(tree);
	while (!s.empty() )
	{
		Node* tmp = s.top();
		cout << key;
		s.pop();
		if (tmp->right != 0)
			s.ВСТАВКА(tmp->right);
		if (tmp->left != 0)
			s.ВСТАВКА(tmp->left);
	}
}
```

####Таблицы

#####Просматриваемые таблицы
Таблица - динамическая структура данных, хранящая однотипные элементы. Записи хранятся в векторе памяти в порядке добавления (добавление производится в конец таблицы). При удалении записи просиходит перепаковка (сдвиг всех записей ниже текущей на одну позицию вверх).

######Основные операции
Полсматриваемые таблицы.
* Вставка `Insert`:
```
ВСТАВИТЬ(record)
{
	recs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ] = record;
	ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ++;
}
```
* Удаление `Delete`:
```
УДАЛЕНИЕ(key)
{
	if(Search(key1) == 0)
		return;	
	delete recs[pos];
	recs[pos] = recs[ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ-1];
	ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ--;
}
```
* Поиск `Search`:
```
НАЙТИ(key)
{
	for (int i=0; i<ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ; i++)
		if(key1 == recs[i]->GetKey())
		{
			pos = i;
			return recs[i];
		}
	return 0;
}
```

#####Упорядоченные таблицы
Упорядоченная таблица - это просматриваемая таблица, данные в которой отсортированы по невозрастанию/неубыванию ключей. Причем при вставке и удалении происходят перепаковки.

######Основная операция
* Сортировка элементов `Sort` (трудоемкость = log(n)):
```
СОРТИРОВКА()
{
	for(int i=0; i<ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ; i++)
		for(int j=i+1; j<ТЕКУЩЕЕ_КОЛИЧЕСТВО_ЗАПИСЕЙ; j++)
			if(recs[i]->key > recs[j]->key)
			{
				TabRecord* tmp = recs[i];
				recs[i] = recs[j];
				recs[j] = tmp;
			}
}
```

####Приоритетные очереди
Приоритетная очередь — это динамическая структура данных, содержащая элементы, каждый из которых имеет определенный приоритет. Элемент с более высоким приоритетом находится перед элементом с более низким приоритетом. Если у элементов одинаковые приоритеты, они располагаются в зависимости от своей позиции в очереди. 

######Основные операции:
* Вставка элемента `Push`.
* Удаление элемента с максимальным приоритетом `Pop`.
* Получение элемента с максимальным приоритетом `Top`.
* Проверка очереди на пустоту `IsEmpty`.
* Проверка очереди на полносту `IsFull`.

####Разделенные множества
Разледенные множества - абстрактный тип данных, предназначенный для представления коллекции из некоторого числа k попарно непересекающихся подможеств заданного множества.

######Основные операции
* Создание синглтона `CreateSingleton` (трудоемкость = О(1)):
```
СОЗДАНИЕ_СИНГЛТОНА(x)
{
	parent[x] = x;
	height[x] = 0;
}
```
* Объединение множеств `Union` (трудоемкость = О(n)):
```
ОБЪЕДИНЕНИЕ_МНОЖЕСТВ(x,y)
{
	if (height[x] > height[y])
		parent[y] = x;
	else 
		if (height[x] < height[y])
			parent[x] = y;
		else
		{
			parent[y] = x;
			height[x]++;
		}
}
```
* Поиск подмножества `FindSubset` (трудоемкость = О(1)):
```
ПОИСК_ПОДМНОЖЕСТВА(x)
{
	int i = x, c = -1;
	if (p[x]!=x)
		while (i!=p[i])
		{
			c = p[i];
			i = p[c];
		}
	return i;
}
```

###Описание алгоритмов

####Пирамидальная сортировка
1. На вход поступает 2 значения: арность кучи и количество элементов.
2. Формируется куча.
3. Минимальный элемент d-кучи меняется с последним.
4. Размер d-кучи уменьшаем на 1.
5. Погружаем нулевой элемент.
6. 3-5 повторяется size-1 раз.

Таким образом, значения будут отсортированы по возрастанию.

####Алгоритм Дейкстры

1. На вход поступает количество вершин, значения веса ребер, соединяющих вершины i и j.
2. Формируется граф `graph`.
3. Создается массив `up`, содержащий вершины, предшествующие вершине i при обходе по дереву. Всем элементам присваивается -1.
4. Создается массив `dist` (все элементы равны `MAX`, `dist[0] = 0`). dist[i] - кратчайшее растояние от 0 до вершины i.
5. Первая вершина объявляется текущей.
. На выходе получим 2 массива: 
    - Массив `dist` содержит кратчайшие расстояния до каждой вершины графа `graph`.
    - Массив `up` содержит предшествующие вершины.

####Алгоритм Краскала
